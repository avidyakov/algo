"""ID посылки: 53723659

-- ПРИНЦИП РАБОТЫ --
Мы проходимся по всему списку операндов и операций в постфиксной нотации. Если на вход подан операнд, то мы помещаем его
в стек, а если на вход подан знак операции, то мы забираем два элемента из стека и выполняем над ними нужную операцию.
Результат операции мы помещаем в стек. В самом конце мы просто забираем один элемент из стека.

Стек реализован на простом массиве.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Мы проходимся по всему списку длиной n. Операция добавления в стек и удаления занимает О(1) т.к. стек реализован
с помощью массива, а как мы знаем добавление элемента в конец массива, и его удаление занимает константное время.
Каждую итерацию мы добавляем один элемент в стек и если элемент списка является операцией, то мы еще два раза
извлекаем элемент из стека. Сложность алгоритма в худшем случае 3n -> O(n).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
В худшем случае нам придется заполнить наш стек длиной входного массива n. Тогда
пространственная сложность алгоритма = O(n).
"""

from operator import add, floordiv, mul, sub

OPERATIONS = {
    '+': add,
    '-': sub,
    '*': mul,
    '/': floordiv
}


def calc(expression: list[str]) -> int:
    """ Вернуть значение выражения в постфиксной нотации.
    >>> calc('-4 -5 +'.split())
    -9
    >>> calc('4 -5 * -6 2 / + -3 1 * -10 10 - - + 8 4 / -3 4 + + 7 1 / -4 9 * - / +'.split())
    -6
    >>> calc('-3 -7 - 1 -10 * * -5 9 / 6 1 * * + 9 2 / 3 3 / / 10 0 - 4 -10 - / * -'.split())
    -46
    """
    stack = []
    for item in expression:
        if item in OPERATIONS:
            number2 = stack.pop()
            number1 = stack.pop()
            to_append = OPERATIONS[item](number1, number2)
        else:
            to_append = int(item)

        stack.append(to_append)

    return stack[-1]


def main() -> None:
    expression = input().split()
    print(calc(expression))


if __name__ == '__main__':
    main()
